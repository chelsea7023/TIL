#  추상클래스(abstract class)
* 클래스는 설계도 아에는 필드(속성),메소드(행위),생성자(construction)+ 중첩 클래스로 이루어짐
* 설계도 중에는 객체 생성이 꼭 필요하지 않은 설게도가 있을 수 있다! 
## 추상 클래스 정의
* cook()메소드는 자손 클래스에서 반드시 재정의해서 사용되기 때문에 조상의 구현이 무의미
* 메서드의 선언부만 남기고 구현부는 ;으로 대체
* 구현부가 없으므로 acstract키워드를 메서드 선언부에 추가
* 객체를 생성할 수 없는 클래스라는 의미로 <u>클래스 선언부에 abstract를 추가</u>(추상클래스)
* 추상 메소드를 하나라도 가지면 무조건 클래스도 추상화 추가
```java
package test04_abstract_method;


// 추상메서드를 하나라도 가지고 있으면,
// 클래스는 추상 클래스이다.
// 클래스에도 abstract 키워드를 붙여준다.
public class Chef {
    String name;
    int age;
    String speciality;
    
    public void eat() {
        System.out.println("음식을 먹는다.");
    }
    // 부모클래스의 메소드를 삭제하는 것이 아니라
    // 추상 메소드로 만든다.
    // - 구현부 삭제 => 세미클론
    // - abstract 키워드를 붙인다.

    public abstract void cook();
}

	// 1. 다형성 활용 가능
	// 2. 자식클래스에서 반드시 오버라이드해서 구현해야함. (구현의 강제)
```
## 추상클래스 특징
* abstract 클래스는 상속 전용의 클래스
* 클래스에 구현 부가 없는 메서드가 있으므로 객체를 생성할 수 없음
* 상위 클래스 타입으로 지식을 참조할 수는 있음
```java
//생성할 수 없음
Chef chef1 = new Chef();
//참조는 문제 없음
Chef chef2 = new KFoodChef();
```
* 조상클래스에서 상속 받은 abstract 메서드를 재정의 하지 않은 경우
  
# 인터페이스
* 서로 다른 장치들을 연결시켜 주는 규격
* 핸드폰의 아이콘도 어찌보면 인터페이스 => 스마트폰과 사람 사이의 연결고리가 되어 주기 때문에
* 대표적인 예시) hdmi
* 약속으로 이해하면 좋다
* 완벽히 추상화된 설계도
* 클래스와 유사하게 작성이 가능(class 대신 interface 키워드 사용)
* 모든 메서드가 추상 메서드 (JDK8부터 default method, static method추가)
* 인터페이스는 결국 약속인데, 이 추상메서드를 구현하겠다는 약속으로 이해하면 된다.
```java
public interface 인터페이스이름 {
    public static final 타입 상수이름 1 = 10;
    (생략가능) 타입 상수이름 상수이름2 = 10;

    public abstract 반환형 메서드이름1(타입 매개변수...);
    (생략가능)반환형 메더스이름2(타입 매개변수 ...);
}
```
```java
// 클래스 : class
// 인터페이스 : interface
// 인터페이스로 객체 생성 가능? XX
// 클래스가 이 인터페이스를 구현하도록 하고, 그 클래스로 객체 생성.

public interface MyInterface {
	//인터페이스의 모든 변수는 상수
	public static final int MEMBER1 = 10; // 관습적으로 상수는 대문자로 표현.
	int MEMBER2 = 20; // public static final 생략되어 있다.
	
	// 인터페이스의 모든 메서드는 추상메서드
	public abstract void method1(); // 약속.
	void method2(); // public abstract 생략되어 있음.
	
	// 반환형도 가능하고 매개변수도 들어갈 수 있다.
}
```
## 인터페이스 구현
* 인터페이스는 그 자체로 인스턴스를 생성할 구 없음 (구현부X)
* 인터페이스 내에 있는 메서드를 구현할 클래스가 필요함
```java
interface MyInterface{}

public class Main {
    MyInterface m = New MyInterface();
}
```
* extends 대신 implements 키워드를 사용하여 구현 클래스 작성
```java
interface Shape{}

class Circle extends shape {} XXXX
class Circle implements shape{} OOOO
```
* 클래스 클래스 상속은 단일 상속
* 클래스 인터페이스 구현은 다중 구현 가능
* 인터페이스는 인터페이스를 다중 상속 가능하다
* 인터페이스를 구현하는 클래스는 추상 메소드를 반드시 오버라이딩(재정의)해야 한다.
## 인터페이스 상속
* extends를 이용하여 상속이 가능
* 다중 상속이 가능(클래스의 다중 상속에서의 문제가 없음)
## default method
* 인터페이스에 구현부가 있는 메서드를 작성할 수 있음
* 메서드 앞에 default라는 키워드를 작성 해야함
* public 접근제한자를 사용해야 하며 생략 가능 (안써도 public이기 때문에)
* 이유는? 갑자기 우리가 인터페이스에 메서드 하나를 추가 하고 싶을때 전부 오버라이딩 해야하는 수고가 들어감.
## static method
* 클래스의 static 메서드와 사용방법이 동일함.(객체 생성 없이 클래스 명으로 바로 접근 가능하듯이 인터페이스 이름으로 바로 접근 가능)
* 인터페이스 이름으로 메서드에 접근하여 사용
##
### *두 개의 메소드 모두 구현부가 있으므로 충돌 발생 가능하다. 다중 구현시에는 반드시 오버라이드 해줘야한다*
인터페이스끼리 충돌 났을 때는 반드시 오버라이드, 인터페이스와 조상끼리 겹치면 조상클래스 사용.
## 인터페이스의 필요성
* 표준화 처리 가능
* 개발 기간 단축 가능
* 서로 관계가 없는 클래스들에게 인터페이스를 통해 관계를 맺을 수 있음
* 독립적 프로그래밍 가능
* 인터페이스를 통한 간접적인 클래스 사용으로 손쉬운 모듈 교체 지원

# 인터페이스 VS 클래스
## 클래스와 인터페이스 비교
| | 클래스 | 인터페이스 |
|---|---|---|
|특징|class 키워드를 사용하여 정의, 필드와 메서드, 생성자로 이루어짐| interface 키워드를 사용하여 정의, 상수와 추상메소드(메소드 선언부)로 이루어짐 public static final 생략 public abstract 생략|
|관계|인터페이스를 구현함|클래스에 의해 구현됨|
|멤버 변수|선언가능|상수만가능|
|다중 상속|클래스는 하나의 클래스만 상속 가능| 인터페이스는 여러 개의 인터페이스 상속 가능(구현부가 없으므로 헷갈리지 않음)|
|다중 구현| 클래스는 여러 개의 인터페이스를 다중으로 구현(implements) 가능||
|인스턴스|생성 가능|생성 불가|
|타입|타입으로 사용 가능|타입으로 사용 가능|


## 추상클래스와 인터페이스 비교
| - | 추상 클래스 | 인터페이스 |
|:----:|:----:|:----:|
| 객체생성 | 불가 | 불가 |
|일반 메소드 |가능|불가|
|일반 필드|가능|불가(상수만 가능)|
|메서드|abstract를 붙여야만 추상 메소드|모든 메소드는 추상 메소드|
|사용|- 추상적인 클래스의 성격을 가질 때(일부 메소드만 미완성인 설계도) <br> -서로 유사한 클래스 사이에 코드를 공유하고 싶을때| - 서로 관련없는 클래스 사이에 공통으로 적용된 인터페이스를 구현하기를 원할 때,ex) Comparable, Serializable <br> - 객체(클래스)의 성격이라기보다 어떤 기능을 구현하고 있다는 약속의 성격이 있을 때| 

# Generic 
## 제네릭
* 다양한 종류의 객체들을(여러 타입의 클래스 => 타입을 파라미터처럼 사용 => 타입에 대한 일반화) 다루는 메서드나 컬렉션 클래스에서 컴파일 시 타입을 체크 해주는 기능.
* 객체의 타입 안정성을 제공한다.
* 형변환의 번거러움이 없어지므로 코드가 간결해진다.
## 제네릭 클래스
*  클래스를 정의할 때
*  클래스 안에서 사용되는 자료형 (타입)을 구체적으로 명시하지 않고
*  T와 같이 타입 매개변수를 이용하는 클래스
*  오버로딩이랑 비슷한 개념 => 매번 타입 때문에 이름을 많이 만들면 번거롭고 코딩이 복잡해짐
```java 
class Box <T>{

}
==>
class Box<Red>, class Box<Blue> 등등
```
## 제네릭 클래스 선언
* 클래스 또는 인터페이스 선언 시 <>에 타입 파라미터 표시 
```java
public class ClassName<T>{}
public interface InterfaceName<T>{}
```
*  타입 파라미터 -> 사용해서 타입의 일반화 가능
  
## 제네릭 클래스 객체 생성
* 변수와 생성 쪽의 타입은 반드시 일치해야함. (상속관계에 있어도 마찬가지)
```java
Box<Student> box = new Box<Student>(); (O)
Box<Person> box = new Box<Student>(); XXXX
```
* 추정이 가능 한 경우 타입 생략 가능(생성자 쪽 생략 가능 JDK 1.7부터)
```java
Box<Student> box = new Box<>();
```
* 제네릭 타입을 지정하지 않고 생성이 가능하지만 권장 X (자동으로 T는 Object)

## 제한된 제네릭 클래스
* 타입 문자로 사용할 타입을 명시하였지만 역시 모든 타입을 사용할 수 있는 문제가 발생
* 구체적인 타입의 제한이 필요할 때 extends키워드를 사용할 수 있음(Person의 자손만 타입 지정 가능)
```java
class Box<T> extends Person {
    private T obj;
    public T getObj(){
        return obj;
    }
    public void setObj(T obj){
        this.obj = obj;
    }
}
```
* 클래스가 아닌 인터페이스로 제한할 경우도 extends 키워드 사용
* 클래스와 함께 인터페이스 제약 조건을 이용할 경우 &로 연결
  
## 와일드 카드 이용
* generic type 에서 구체적인 타입 대신 사용
표현||설명
Generic type<?>|| 타입에 대한 제한이 없음


