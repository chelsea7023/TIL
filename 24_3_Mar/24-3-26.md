# 그래프 탐색(Graph)

## 탐색 기법
* 모든 노드를 빠짐 없이 탐색하는 방법은 두 가지가 있다. 
    1. 깊이 우선 탐색 (Depth First Search, DFS)
    2. 너비 우선 탐색 (Breadth First Search, BFS)

## DFS(Depth First Search)
* 깊이 우선 탐색
* 시작 지점에서 출발하여 한 방향으로 탐색함
* 진행 할 수 없다면 마지막에 만난 지점으로 돌아와 다른 방향 다시 탐색
* 후입 선출(LIFO) 구조의 스택 사용
* 재귀 함수는 System Stack을 활용하므로 간단하게 구현 가능

### 트리 탐색 
1. 루트 노드 -> Stack Push 
2. Stack -> Empty가 될 때까지 반복 수행 
   1. 현재 노드 <- Stack pop
   2. 현재 노드의 모든 자식 -> Stack Push 

![image](https://github.com/chelsea7023/TIL/assets/156149302/f74f6c29-c511-4ffa-a0e0-5649f0cbb5f7)

### 트리 탐색(재귀 함수)
1. 현재 노드 (v)방문
2. (v)의 자식 노드 (w)를 차례로 재귀 호출

![image](https://github.com/chelsea7023/TIL/assets/156149302/797bcbc9-725f-4335-b8a8-4c089d256423)

```java
import java.util.Scanner;

public class 그래프탐색_01_DFS {
	
	static int V; 				// 정점의 수
	static int [][] adj;		// 인접행렬
	static boolean[] visited;	// 방문 체크
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		
		V = sc.nextInt();
		int E = sc.nextInt();
		
		adj = new int[V + 1][V + 1]; // 시작 정점이 1번부터 시작
		visited = new boolean[V + 1];
		
		for(int i = 0; i < E; i++) {
			int A = sc.nextInt();
			int B = sc.nextInt();
			
			adj[A][B] = adj[B][A] = 1;  // 인접행렬 (무향) 
		}
		
//		for(int [] arr : adj) {
//			System.out.println(Arrays.toString(arr));
//		}   간선 정보 입력 완료
		
		DFS(1);
		
	}
	
	public static void DFS(int v) {
		// v 방문 처리
		visited[v] = true;
		System.out.println(v);
		
		
		// 인접한 친구들 방문 (인접행렬, 인접리스트 코드가 다르다)	
		for(int i = 1; i <= V; i++) {
			if(!visited[i] && adj[v][i] == 1) {
				DFS(i);
			}
		}
		
//		인접리스트를 썼을 떄는 아래처럼 사용도 가능(예시)
//		for( int w : adj[v]) {
//			if(!visited[w]) {
//				DFS(w);
//			}
//		}
	}
}
```

